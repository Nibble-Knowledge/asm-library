#how to call the SignedCompare function:
#note that this takes a total of 102 instructions
#The function it calls takes around 180 instructions
#meaning that this is worth it if any 64-bit comparison is called
#more than twice

#Also: SignedCompare need only be included once.
#The same function can be used in several ways to
#solve different versions of comparison.

#as JMPG64 $op1 $op2 TO $dest:
NOT64 $op1 INTO CMP.op1
MOV64 $op2 INTO CMP.op2
MOV16 $dest INTO CMP.jmp1[1]
MOV16 nojump INTO CMP.jmp2[1]
LOD N_[4]
STR CMP.Entry32
STR CMP.Entry16
LOD N_[0]
JMP CMP.Entry64
nojump:
NOP 0

#as JMPL64 $op1 $op2 TO $dest:
NOT64 $op1 INTO CMP.op1
MOV64 $op2 INTO CMP.op2
MOV16 nojump INTO CMP.jmp1[1]
MOV16 $dest INTO CMP.jmp2[1]
LOD N_[4]
STR CMP.Entry32
STR CMP.Entry16
LOD N_[0]
JMP CMP.Entry64
nojump:
NOP 0

#as JMPLE64 $op1 $op2 TO $dest:
NOT64 $op2 INTO CMP.op1
MOV64 $op1 INTO CMP.op2
MOV16 $dest INTO CMP.jmp1[1]
MOV16 nojump INTO CMP.jmp2[1]
LOD N_[4]
STR CMP.Entry32
STR CMP.Entry16
LOD N_[0]
JMP CMP.Entry64
nojump:
NOP 0

#As JMPGE64 $op1 $op2 TO $dest:
NOT64 $op2 INTO CMP.op1
MOV64 $op1 INTO CMP.op2
MOV16 nojump INTO CMP.jmp1[1]
MOV16 $dest INTO CMP.jmp2[1]
LOD N_[4]
STR CMP.Entry32
STR CMP.Entry16
LOD N_[0]
JMP CMP.Entry64
nojump:
NOP 0

#But wait! there's more! We can re-use this function for
#smaller functions! We can even do so efficiently, due to
#the fact that I'm very clever and designed the function
#to be easily modified to streamline the negation

#the permutations of the above function identically here

#As JMPL32
NOT32 $op1 INTO CMP.op1
MOV32 $op2 INTO CMP.op2
MOV16 nojump INTO CMP.jmp1[1]
MOV16 $dest INTO CMP.jmp2[1]
LOD N_[4]
STR CMP.Entry16
LOD N_[1]
STR CMP.Entry32
LOD N_[0]
JMP CMP.Entry32
nojump:
NOP 0

#as JMPL16
NOT16 $op1 INTO CMP.op1
MOV16 $op2 INTO CMP.op2
MOV16 nojump INTO CMP.jmp1[1]
MOV16 $dest INTO CMP.jmp2[1]
LOD N_[1]
STR CMP.Entry16
LOD N_[0]
JMP CMP.Entry16
nojump:
NOP 0




